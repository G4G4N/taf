import click
import taf.developer_tool as developer_tool


def attach_to_group(group):

    @group.group()
    def repo():
        pass

    @repo.command()
    @click.argument("path")
    @click.option("--keys-description", help="A dictionary containing information about the "
                  "keys or a path to a json file which which stores the needed information")
    @click.option("--keystore", default=None, help="Location of the keystore files")
    @click.option("--commit-msg", default=None, help="Commit message. If provided, the "
                  "changes will be committed automatically")
    @click.option("--test", is_flag=True, default=False, help="Indicates if the created repository "
                  "is a test authentication repository")
    def create(path, keys_description, keystore, commit_msg, test):
        """
        Create a new authentication repository at the specified location by registering
        signing keys and generating initial metadata files. Information about the roles
        can be provided through a dictionary - either specified directly or contained
        by a .json file whose path is specified when calling this command. This allows
        definition of:
            - total number of keys per role
            - threshold of signatures per role
            - should keys of a role be on Yubikeys or should keystore files be used

        If this dictionary is not specified, it will be assumed that there should only
        be one signing key and that all keys are stored in keystore files.

        For example:\n
        {\n
            "root": {\n
                "number": 3,\n
                "length": 2048,\n
                "passwords": ["password1", "password2", "password3"]\n
                "threshold": 2,\n
                "yubikey": true\n
            },\n
            "targets": {\n
                "length": 2048\n
            },\n
            "snapshot": {},\n
            "timestamp": {}\n
            }\n

        If keys should be stored in keystore files, it is possible to either use already generated
        keys (stored in keystore files located at the path specified using the keystore option),
        or to generate new one.

        If the test flag is set, a special target file will be created. This means that when
        calling the updater, it'll be necessary to use the --authenticate-test-repo flag.
        """
        developer_tool.create_repository(path, keystore, keys_description, commit_msg, test)

    @repo.command()
    @click.argument("path")
    @click.option("--targets-dir", default=None, help="Directory where the target "
                  "repositories are located. If omitted, it will be assumed that target repositories "
                  "are inside the same repository as the authentication repository")
    @click.option("--namespace", default=None, help="Namespace of the target repositories "
                  "If omitted, it will be assumed that namespace matches the name of the "
                  "directory which contains the target repositories")
    @click.option("--targets-rel-dir", default=None, help="Directory relative to which "
                  "urls of the target repositories are calculated. Only useful when "
                  "the target repositories do not have remotes set")
    @click.option("--custom", default=None, help="A dictionary containing custom "
                  "targets info which will be added to repositories.json")
    def generate_repositories_json(path, targets_dir, namespace, targets_rel_dir, custom):
        """
        Generate repositories.json. This file needs to be one of the authentication repository's
        target files or the updater won't be able to validate target repositories.
        repositories.json is generated by traversing through all target adding an entry
        with the namespace prefixed name of the target repository as its key and the
        repository's url and custom data as its value. The urls correspondond to git remote urls
        if set or to the the repository's location on the file system if that is not the case.
        Test repositories might not have remotes. If targets-rel-dir is specified and a repository
        does not have remote url, its url is calculated as a relative path to the repository's
        location from this path.

        While urls are the only information that the updater needs, it is possible to add
        any other data using the custom option. Custom data can either specified in a .json file
        whose path is provided when calling this command, or directly entered. Keys is this
        dictionary are names of the repositories whose custom data should be set and values are
        custom data dictionaries. For example:

        {\n
	        "test/html-repo": {\n
		        "type": "html"\n
	        },
	        "test/xml-repo": {\n
		        "type": "xml"\n
	        }\n
        }\n

        Note: this command does not automatically register repositories.json as a target file.
        It is recommended that the content of the file is reviewed before doing so manually.
        """
        developer_tool.generate_repositories_json(path, targets_dir, namespace, targets_rel_dir, custom)